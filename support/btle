#!/bin/bash

# ----------------------------------------------------------------------------------------
# GENERAL INFORMATION
# ----------------------------------------------------------------------------------------
#
# Written by Andrew J Freyer
# GNU General Public License
# http://github.com/andrewjfreyer/monitor
#
# BLUETOOTH SCANNING AND PACKET PROCESSING
#
# ----------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------
# BLUETOOTH LE BACKGROUND SCANNING
# ----------------------------------------------------------------------------------------
btle_scanner () {
	while true; do 
		#TIMEOUT THE HCITOOL SCAN TO RESHOW THE DUPLICATES WITHOUT SPAMMING THE MAIN LOOP BY USING THE --DUPLICATES TAG
		local hcitool_raw=$(timeout --signal SIGINT 17 hcitool -i $PREF_HCI_DEVICE lescan 2>&1)

		#FIND ERROR VALUES 
		local error=$(echo "$hcitool_raw" | grep -iE 'input/output error|invalid device|invalid|error|network')

		#PUBLISH ERRORS BACK TO MAIN LOOP
		if [ ! -z "$error" ]; then 

			(>&2 echo "error! attempting to correct $PREF_HCI_DEVICE hardware fault.")

			hciconfig $PREF_HCI_DEVICE down && sleep 5 && hciconfig $PREF_HCI_DEVICE up

			sleep 5
		fi 

		#NEED DELAY TO BE SURE WE'RE NOT RESTARTING HARDWARE TOO QUICKLY
		sleep 2
	done

	#REPORT ERROR
	(>&2 echo "error! irrecoverable btle_scanner error")
}

# ----------------------------------------------------------------------------------------
# PROCESS BLUETOOTH PACKETS
# ----------------------------------------------------------------------------------------

btle_packet_processor () {
	#DEFINE LOCAL VARIABLES
	local should_ignore
	local MAJOR
	local MINOR
	local POWER
	local RSSI
	local UUID
	local adv_data
	local gap_name_str
	local pdu_header
	local pdu_header_bin
	local pdu_type
	local received_mac_address
	local rssi_value
	local rssi_value_raw
	local rx_add
	local tx_add
	local packet
	local should_ignore

	#POPULATE PACKET 
	packet=$(echo "$1" | sed 's/> *//g;s/[^0-9A-F ]//g')

	#BEACON PACKET?
	if [[ $packet =~ ^04\ 3E\ 2A\ 02\ 01\ .{26}\ 02\ 01\ .{14}\ 02\ 15 ]]; then

		#HARDARE MAC AND PDU HEADER
		received_mac_address=$(echo "$packet" | awk '{print $13":"$12":"$11":"$10":"$9":"$8}')
		pdu_header=$(pdu_type $(echo "$packet" | awk '{print $6}'))

		#RAW VALUES
		UUID=$(echo "$packet" | sed 's/^.\{69\}\(.\{47\}\).*$/\1/')
		MAJOR=$(echo "$packet" | sed 's/^.\{117\}\(.\{5\}\).*$/\1/')
		MINOR=$(echo "$packet" | sed 's/^.\{123\}\(.\{5\}\).*$/\1/')
		POWER=$(echo "$packet" | sed 's/^.\{129\}\(.\{2\}\).*$/\1/')
		UUID=$(echo "$UUID" | sed -e 's/\ //g' -e 's/^\(.\{8\}\)\(.\{4\}\)\(.\{4\}\)\(.\{4\}\)\(.\{12\}\)$/\1-\2-\3-\4-\5/')
	
		#MAJOR CALCULATION
		MAJOR=$(echo $MAJOR | sed 's/\ //g')
		MAJOR=$(echo "ibase=16; $MAJOR" | bc)

		#MINOR CALCULATION
		MINOR=$(echo $MINOR | sed 's/\ //g')
		MINOR=$(echo "ibase=16; $MINOR" | bc)

		#POWER CALCULATION
		POWER=$(echo "ibase=16; $POWER" | bc)
		POWER=$((POWER - 256))

		#RSSI CALCULATION
		RSSI=$(echo "$packet" | sed 's/^.\{132\}\(.\{2\}\).*$/\1/')
		RSSI=$(echo "ibase=16; $RSSI" | bc)
		RSSI=$((RSSI - 256))

        #CLEAR PACKET
        packet=""

		#SEND TO MAIN LOOP
		if [ ! -z "$UUID" ]; then 
			echo "BEAC$UUID|$MAJOR|$MINOR|$RSSI|$POWER|$received_mac_address|$pdu_header" > main_pipe & 
			disown "$!"
		fi 
	
	elif [[ $packet =~ ^04\ 3E\ .* ]]; then

		#GET RANDOM ADDRESS; REVERSE FROM BIG ENDIAN
		received_mac_address=$(echo "$packet" | awk '{print $13":"$12":"$11":"$10":"$9":"$8}')
		
		#VERIFY ADDRESS DOES NOT START WITH 00
		#[[ "$received_mac_address" =~ ^00 ]] && return 0

		#TWO BYTES ARE PDU HEADER
		pdu_header=$(echo "$packet" | awk '{print $7$6}' )
		pdu_header_bin=$(echo "ibase=16;obase=2;$pdu_header" | bc | xargs printf "%016d")

		#TxADD
		tx_add=${pdu_header_bin:7:1}
		[[ $tx_add == 0 ]] && tx_add="PUBL" || tx_add="RAND"

		rx_add=${pdu_header_bin:8:1}
		[[ $rx_add == 0 ]] && rx_add="PUBL" || rx_add="RAND"

		#BREAKOUT OF PDU HEADER INFORMATION 
		pdu_type=$(pdu_type $(echo "ibase=2;${pdu_header_bin:12:4}" | bc ))

		#ADVERTISED DATA
		adv_data="$packet"

		#RSSI VALUE
		rssi_value_raw="${packet: -3}"
		rssi_value=$(echo "ibase=16;$rssi_value_raw" | bc )
		rssi_value=$((rssi_value - 256))

		gap_name_str=""

		#IF THIS IS A SCAN RESPONSE, FIND WHETHER WE HAVE USABLE GAP NAME DATA 
		if [ "$pdu_type" == 'SCAN_RSP' ] || [ "$pdu_type" == "ADV_NONCONN_IND" ]; then 
			gap_name_str=$(gap_name "$packet")
        fi

		#FILTER BASED ON RESPONSE/DATA TYPE		
        if [ "$pdu_type" == "ADV_IND" ] || [ "$pdu_type" == "ADV_NONCONN_IND" ] || [ "$pdu_type" == "SCAN_RSP" ] ; then 
			#SEND TO MAIN LOOP ONLY IF PASSES RSSI  THRESHOLD

			should_ignore=false 
			[ "$tx_add" == "RAND" ] && [ ! -z "$rssi_value" ] && [[ "$PREF_RSSI_IGNORE_BELOW" -gt "$rssi_value" ]] && should_ignore=true 
			[ ! -z "$gap_name_str" ] && should_ignore=false 

			if [ "$should_ignore" == false ]; then 
				#REPORT TO MAIN LOOP
				echo "$tx_add$received_mac_address|$pdu_type|$gap_name_str|$rssi_value|$adv_data" > main_pipe & 
				disown "$!"
			else 
				(>&2 echo "error 1: rejecting packet $packet")
				return 0
			fi 
		fi 

	#NAME REQUEST RESPONSES
	elif [[ $packet =~ ^04\ 07.* ]]; then
		return 0	
	fi

	(>&2 echo "error 2: rejecting packet [$packet]")
}

# ----------------------------------------------------------------------------------------
# BLUETOOTH LE RAW PACKET ANALYSIS
# ----------------------------------------------------------------------------------------
btle_listener () {
        #LOCAL VALUES 
	local packet
    local complete_packet_str_length
	local packet_len
	local line 
		
	#DEFINE VARAIBLES
	while true; do 
		packet=""
		complete_packet_str_length=0
		while read -r line; do
			# packets start with ">" or "<"
			if [[ $line =~ ^\> ]] || [[ $line =~ ^\< ]]; then
				# process the completed packet (unless this is the first time through)
				if [ "$packet" ] && [[ $packet =~ ^\> ]]; then
					btle_packet_processor "$packet" & 
					disown "$!"
				fi
				# start the new packet
				packet=$line
				complete_packet_str_length=0

				if [[ "$packet" =~ ^\>\ 04\ 3E* ]]; then
					packet_len=$(echo "$packet" | awk '{print "ibase=16;"$4}' | bc )
					complete_packet_str_length=$((( packet_len + 3) * 3  + 1))
				fi 
			else
				# continue building the packet
				packet="$packet $line"

				#PROCESS A PACKET WHEN IT IS COMPLETE
				if [ "$complete_packet_str_length" == "${#packet}" ]; then 
					btle_packet_processor "$packet" &
					disown "$!"
					packet=""
				fi 
			fi
		done < <(timeout --signal SIGINT 71 hcidump -i "$PREF_HCI_DEVICE" --raw)

		#TEST: PREVENT HCIDUMP FROM LEAKING MEMORY
		sleep 2
	done 

	#REPORT ERROR
	(>&2 echo "error! irrecoverable btle_listener error")
}