#!/bin/bash

# ----------------------------------------------------------------------------------------
# GENERAL INFORMATION
# ----------------------------------------------------------------------------------------
#
# Written by Andrew J Freyer
# GNU General Public License
# http://github.com/andrewjfreyer/monitor
#
# BLUETOOTH SCANNING AND PACKET PROCESSING
#
# ----------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------
# BLUETOOTH LE BACKGROUND SCANNING
# ----------------------------------------------------------------------------------------
btle_scanner () {
	while true; do 
		#TIMEOUT THE HCITOOL SCAN TO RESHOW THE DUPLICATES WITHOUT SPAMMING THE MAIN LOOP BY USING THE --DUPLICATES TAG
		local hcitool_raw=$(timeout --signal SIGINT 300 hcitool -i $PREF_HCI_DEVICE lescan 2>&1)

		#FIND ERROR VALUES 
		local error=$(echo "$hcitool_raw" | grep -iE 'input/output error|invalid device|invalid|error|network')

		#PUBLISH ERRORS BACK TO MAIN LOOP
		if [ -n "$error" ]; then 

			(>&2 echo "error! attempting to correct $PREF_HCI_DEVICE hardware fault.")

			#POWER CYCLE
			hciconfig $PREF_HCI_DEVICE down
			sleep 5 
			hciconfig $PREF_HCI_DEVICE up
		fi 

		#NEED DELAY TO BE SURE WE'RE NOT RESTARTING HARDWARE TOO QUICKLY
		sleep 10
	done

	#REPORT ERROR
	(>&2 echo "error! irrecoverable btle_scanner error")
}

#----------------------------------------------------------------------------------------
# PROCESS BLUETOOTH PACKETS
# ----------------------------------------------------------------------------------------

trim_whitespace () {
	[[ "$1" =~ [^[:space:]](.*[^[:space:]])? ]] && printf "%s" "$BASH_REMATCH"
}


btle_text_processor () {
	local received_mac_address
	local packet
	local pdu_type
	local rssi_value
	local gap_name_str
	local should_ignore
	local manufacturer
	local flags
	local device_type
	local oem_data
	local version

	#BEACON
	local uuid
	local tx_power


 	if [ -n "$1" ]; then 
 		#DEFINE PACKET VARIABLE
 		packet="$1"

		#RETUREN FROM NAME REQUEST
		if [[ $packet =~ Event:\ Remote ]]; then 
			return 0
		fi
		
		#------------ MAC ADDRESS
		if [[ $packet =~ Address:\ ([^|\(]*)\  ]]; then 
			received_mac_address=${BASH_REMATCH[1]}
			received_mac_address=${received_mac_address^^}
		else 
			return 0
		fi 

		#------------ PDU TYPE
		if [[ $packet =~ Event\ type:\ ([^|\(]*)\  ]]; then 
			pdu_type=${BASH_REMATCH[1]}
			pdu_type=${pdu_type##* }
		else 
			return 0
		fi 

		#------------ ADVERTISEMENT TYPE
		if [[ $packet =~ Random ]] || [[ $packet =~ Public ]]; then 
			tx_type=${BASH_REMATCH^^}
			tx_type=${tx_type:0:4}
		fi 

		#------------ RSSI 
		if [[ $packet =~ RSSI[^:]*?:([^|\(]*) ]]; then 
			rssi_value=${BASH_REMATCH[1]}
			rssi_value=${rssi_value//[^-0-9]/}
		fi 

		#------------ NAME
		if [[ $packet =~ Name[^:]{0,}:\ {0,}([^|\(]*)\ {0,}(\||$|\() ]]; then 
			gap_name_str=${BASH_REMATCH[1]}
			gap_name_str=$(trim_whitespace "$gap_name_str")
		fi 

		#------------ MANUFACTURER OF RADIO
		if [[ $packet =~ Company:\ {0,}([^|\(]*)\ {0,}(\||$|\() ]]; then 
			manufacturer=${BASH_REMATCH[1]}
			manufacturer=$(trim_whitespace "$manufacturer")
		fi 

		#------------ ADVERTISEMENT
		if [[ $packet =~ Data:\ {0,}([^|\(]*)\ {0,}(\||$|\() ]]; then 
			adv_data=${BASH_REMATCH[1]}
		fi 

		#------------ DEVICE TYPE
		if [[ $packet =~ Type:\ {0,}([^|\(]*)\ (\||$|\() ]]; then 
			device_type=${BASH_REMATCH[1]}
		fi 

		#------------ FLAGS 
		if [[ $packet =~ Flags:\ {0,}([^|\(]*)(\||$|\() ]]; then 
			flags=${BASH_REMATCH[1]}
		fi 

		#------------ OEM DATA 
		if [[ $packet =~ 1\ entry\|\ {1,}([^|\(]*)\ {1,}(\||$|\() ]]; then 
			oem_data=${BASH_REMATCH[1]}
		fi 

		#------------ UUID
		if [[ $packet =~ UUID:\ {0,}([^|\(]*)(\||$|\() ]]; then 
			uuid=${BASH_REMATCH[1]}

			echo "$uuid" >&2 

			#NEED TO CORRECT BTMON ENDIANNNESS
			uuid=${uuid//-/}; 
			uuid=$(tac -rs .. <<< $uuid)
			uuid="${uuid:0:9}-${uuid:9:4}-${uuid:13:4}-${uuid:17:4}-${uuid:21:12}"

			echo "$uuid" >&2 

			#------------ TX POWER
			if [[ $packet =~ TX\ power:\ {0,}([^|]{1,})(\||$) ]]; then 
				tx_power=${BASH_REMATCH[1]}
			fi 			

			#------------ TX POWER
			if [[ $packet =~ Version:\ {0,}([^|]{1,})(\||$) ]]; then 
				version=${BASH_REMATCH[1]}
			fi 

			printf "%s\n" "BEAC$uuid|MAJ|MIN|$rssi_value|$tx_power|$received_mac_address|$pdu_type|$version" > main_pipe
			return 0
		fi 

		if [ "$tx_type" == "PUBL" ]; then 
			#PRINT ALL PUBLIC BEACONS
			printf "%s\n" "$tx_type$received_mac_address|$pdu_type|$gap_name_str|$rssi_value|$adv_data|$manufacturer|$device_type|$flags|$oem_data" > main_pipe &
			disown "$!"

		elif [ "$tx_type" == "RAND" ]; then
		 
			if [ "$pdu_type" == "ADV_IND" ] || [ "$pdu_type" == "ADV_NONCONN_IND" ] || [ "$pdu_type" == "SCAN_RSP" ] ; then 
				#IF THIS DOES NOT HAVE A UUID, PROCESS AS GENERIC BEACON
				should_ignore=false 
				[ "$tx_type" == "RAND" ] && [ -n "$rssi_value" ] && [[ "$PREF_RSSI_IGNORE_BELOW" -gt "$rssi_value" ]] && should_ignore=true 

				#IF WE HAVE A NAME, DEFINITELY REPORT
				[ -n "$gap_name_str" ] && should_ignore=false 

				if [ "$should_ignore" == false ]; then 
					#REPORT TO MAIN LOOP
					printf "%s\n" "$tx_type$received_mac_address|$pdu_type|$gap_name_str|$rssi_value|$adv_data|$manufacturer|$device_type|$flags|$oem_data" > main_pipe &
					disown "$!"
				fi 
			fi 
		fi 
	fi
}

# ----------------------------------------------------------------------------------------
# BLUETOOTH LE RAW PACKET ANALYSIS
# ----------------------------------------------------------------------------------------
btle_text_listener () {
    while true; do 
	    #LOCAL VALUES 
		local packet
		local line 
			
		#DEFINE VARAIBLES
		while IFS= read -r line; do
			if [[ $line =~ ^\> ]] || [[ $line =~ ^\< ]] || [[ $line =~ RSSI ]]; then
				[[ $line =~ RSSI ]] && packet="$packet|$line"

				if [[ $packet =~ ^\> ]]; then 
					btle_text_processor "$packet" & 
					disown "$!"
				fi 

				packet=""
				packet=$line
			else 		
				packet="$packet|$line" 
			fi
		done < <(timeout --signal SIGINT 400 stdbuf -o0 btmon 2>&1)

		#PREVENT MEMORY 
		sleep 5
	done 
	#REPORT ERROR
	(>&2 echo "error! irrecoverable btle_text_listener error")
}
